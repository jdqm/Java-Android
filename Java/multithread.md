
#1.理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。

有如下一个类A
```
class A {
    public synchronized void a() {
    }
    public synchronized void b() {
    }
}
```
然后创建两个对象
```
A a1 = new A();
A a2 = new A();
```
然后在两个线程中并发访问如下代码：
```
Thread1                       Thread2
a1.a();                           a2.a();
```
请问二者能否构成线程同步？

如果A的定义是下面这种呢？
```
class A {
    public static synchronized void a() {
    }
    public static synchronized void b() {
    }
}
```
答：能不能实现线程同步，主要看它们是否在竞争同一个同步监视器，Java中的任何对象都可以作为同步监视器（锁对象）

- 对于实例同步方法，隐式锁是当前实例对象；

- 对于静态同步方法，隐式锁是类所对应的java.lang.Class对象；

- 对于同步代码块，锁是synchonized(obj)括号里配置的对象。

```
Thread1             Thread2          
a1.a();             a2.a();
 
```
如果a()是普通的同步方法，Thread1的同步监视器是a1，而Thread2的同步监视器是a2，监视器不同，无竞争可言，所以不构成线程同步，下面这种方式可构成线程同步。

```
Thread1             Thread2          
a1.a();             a1.a();
```

而如果将方法定义为静态同步方法，Thread1、Thread2的同步监视都是类A所对应的Class对象，在同一个虚拟机中，同一个类的Class对象是唯一的，所以构成线程同步。

上面这两种说法还存在一个漏洞，没有说是不是在同一个进程中。在Android中每个进程对应着一个不同的虚拟机，每个虚拟机的内存地址空间都是独立的，如果Thread1、Thread2属于不同的进程，类A所对应的Class对象也是两个不同的实例。

这个问题可以延伸出出一个更底层一点的问题：synchronized是如何实现一个线程获得同步锁后，其他的线程就不能获得的，或者是说对象锁的状态信息存在哪里？

对象锁的状态信息保存在对象的头信息中的Mark Word中，相关的还有Lock Record，当被锁定、解锁等时候这些状态信息就会改变，当然了，这些状态信息的改变也要保证原子性，否则也是不安全的。详情可移步《深入理解Java虚拟机：JVM高级特性与最佳实践》第五部分。







